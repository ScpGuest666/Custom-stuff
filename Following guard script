-- Utility function to create buttons with rounded corners
local function createButton(parent, position, size, bgColor, text, scaled)
	local button = Instance.new("TextButton")
	button.Parent = parent
	button.Size = size
	button.Position = position
	button.BackgroundColor3 = bgColor
	button.Text = text
	button.TextScaled = scaled
	button.BorderSizePixel = 0

	-- Rounded corners for a modern look
	local uicorner = Instance.new("UICorner")
	uicorner.CornerRadius = UDim.new(0, 5)
	uicorner.Parent = button

	return button
end

-- Create ScreenGui with optional rounded background for the frame
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false

local frame = Instance.new("Frame")
frame.Parent = screenGui
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
frame.Size = UDim2.new(0, 220, 0, 260) -- Adjusted height for new Guard button
frame.Position = UDim2.new(0.5, -110, 0.5, -130) -- Adjusted position
frame.Active = true
frame.Draggable = true

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 10)
uicorner.Parent = frame

-- TextBox for player input
local playerInput = Instance.new("TextBox")
playerInput.Parent = frame
playerInput.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
playerInput.Size = UDim2.new(0, 180, 0, 30)
playerInput.Position = UDim2.new(0, 20, 0, 20)
playerInput.PlaceholderText = "Enter Player Name"
playerInput.TextScaled = true
playerInput.TextColor3 = Color3.fromRGB(0, 0, 0)

-- Create Buttons: On, Off, Guard, Destroy, Increase/Decrease Distance, Addition
local onButton = createButton(frame, UDim2.new(0, 20, 0, 60), UDim2.new(0, 80, 0, 30), Color3.fromRGB(0, 255, 0), "On", true)
local offButton = createButton(frame, UDim2.new(0, 120, 0, 60), UDim2.new(0, 80, 0, 30), Color3.fromRGB(255, 0, 0), "Off", true)
local guardButton = createButton(frame, UDim2.new(0, 20, 0, 100), UDim2.new(0, 180, 0, 30), Color3.fromRGB(100, 100, 255), "Guard: Off", true)
local pathfindButton = createButton(frame, UDim2.new(0, 20, 0, 140), UDim2.new(0, 180, 0, 30), Color3.fromRGB(255, 255, 0), "Pathfind: Off", true)
local destroyButton = createButton(frame, UDim2.new(0, 20, 0, 180), UDim2.new(0, 180, 0, 30), Color3.fromRGB(255, 255, 255), "Destroy", true)
local plusButton = createButton(frame, UDim2.new(0, 20, 0, 220), UDim2.new(0, 40, 0, 30), Color3.fromRGB(0, 255, 255), "+", true)
local additionButton = createButton(frame, UDim2.new(0, 80, 0, 220), UDim2.new(0, 60, 0, 30), Color3.fromRGB(150, 150, 150), "Addition: Off", true) -- New Addition button
local minusButton = createButton(frame, UDim2.new(0, 160, 0, 220), UDim2.new(0, 40, 0, 30), Color3.fromRGB(255, 165, 0), "-", true)

-- Status Label
local statusLabel = Instance.new("TextLabel")
statusLabel.Parent = frame
statusLabel.Size = UDim2.new(0, 220, 0, 30)
statusLabel.Position = UDim2.new(0, 0, 0, -30)
statusLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
statusLabel.Text = "Status: Off"
statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
statusLabel.TextScaled = true
statusLabel.Font = Enum.Font.SourceSansBold

-- Variables for managing distances
local followDistance = 3
local dodgeDistance = 3
local lookAtEnabled = false
local pathfindingEnabled = false -- Initially pathfinding is off
local guardEnabled = false -- New variable for Guard mode
local isShaking = false
local lastPosition = nil
local movementCheckInterval = 0.5 -- Time in seconds to check for movement
local notMovingCounter = 0 -- Counter to check if the character hasn't moved in several checks

local targetPlayer = nil

-- Frame 2 variables
local frame2 = nil
local additionEnabled = false
local warningEnabled = false -- New variable for Warning mode
local warningButton = nil -- Reference to the warning button in frame2

-- Warning mode specific variables
local warningRange = 15 -- How close a player needs to be to trigger warning
local warningStopDistance = 3 -- How far to stop from the warned player

-- Function to find a player by partial name
local function findPlayerByName(partialName)
	partialName = string.lower(partialName)
	for _, player in pairs(game.Players:GetPlayers()) do
		if player == game.Players.LocalPlayer then continue end -- Don't target self
		if string.find(string.lower(player.Name), partialName) or string.find(string.lower(player.DisplayName), partialName) then
			return player
		end
	end
	return nil
end

-- Pathfinding service
local PathfindingService = game:GetService("PathfindingService")

-- Function to calculate path
local function calculatePath(start, goal)
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(start, goal)
	return path
end

-- Guard mode specific variables
local guardMoveCooldown = 2 -- seconds
local lastGuardMoveTime = 0

-- Enhanced movement function to follow the target player
local function moveToPlayer(targetPlayer)
    local localPlayer = game.Players.LocalPlayer
    local localCharacter = localPlayer.Character
    local localHumanoid = localCharacter and localCharacter:FindFirstChildOfClass("Humanoid")
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

    if not localHumanoid or not localRootPart then return end

    -- --- WARNING MODE LOGIC ---
    -- Only activate if warningEnabled is true AND guardEnabled is true
    if warningEnabled and guardEnabled then
        local closestPlayer = nil
        local minDistance = warningRange + 1 -- Initialize with a value outside the range

        for _, player in pairs(game.Players:GetPlayers()) do
            if player == localPlayer then continue end -- Don't warn self

            local char = player.Character
            local rootPart = char and char:FindFirstChild("HumanoidRootPart")

            if rootPart then
                local distance = (localRootPart.Position - rootPart.Position).Magnitude
                if distance <= warningRange and distance < minDistance then
                    minDistance = distance
                    closestPlayer = player
                end
            end
        end

        if closestPlayer then
            local targetChar = closestPlayer.Character
            local targetRootPart = targetChar and targetChar:FindFirstChild("HumanoidRootPart")

            if targetRootPart then
                local distanceToWarned = (localRootPart.Position - targetRootPart.Position).Magnitude

                -- Stop 3 studs away
                if distanceToWarned > warningStopDistance + 0.5 then -- Add a small buffer
                    local direction = (targetRootPart.Position - localRootPart.Position).unit
                    local destination = targetRootPart.Position - (direction * warningStopDistance)
                    localHumanoid:MoveTo(destination)
                else
                    -- Stop moving if close enough
                    localHumanoid.WalkSpeed = 0
                    task.wait(0.1) -- Give it a moment to stop
                    localHumanoid.WalkSpeed = 16 -- Restore walkspeed
                end

                -- Face the player
                local lookAtVector = targetRootPart.Position - localRootPart.Position
                local lookAtCFrame = CFrame.lookAt(localRootPart.Position, localRootPart.Position + Vector3.new(lookAtVector.X, 0, lookAtVector.Z))
                localRootPart.CFrame = lookAtCFrame * CFrame.Angles(0, math.rad(localRootPart.Orientation.Y), 0) -- Maintain current Y orientation

                return -- Exit early, Warning mode takes precedence
            end
        end
    end
    -- --- END WARNING MODE LOGIC ---

    -- Normal follow/dodge/guard logic (only if Warning mode is not active or not triggered)
    local targetRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")

    if not targetRootPart then return end

    local distance = (localRootPart.Position - targetRootPart.Position).Magnitude

    -- Guard mode logic
    if guardEnabled then
        local currentTime = tick()

        -- If outside followDistance, use pathfinding to get back into range
        if distance > followDistance + 2 then -- A small buffer to re-engage pathfinding
            if not pathfindingEnabled then
                pathfindingEnabled = true
                pathfindButton.Text = "Pathfind: On"
                pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
            end
            local path = calculatePath(localRootPart.Position, targetRootPart.Position)
            if path.Status == Enum.PathStatus.Success then
                local waypoints = path:GetWaypoints()
                for i, waypoint in ipairs(waypoints) do
                    if i > 1 then
                        localHumanoid:MoveTo(waypoint.Position)
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            localHumanoid.Jump = true
                        end
                        localHumanoid.MoveToFinished:Wait()
                        break
                    end
                end
            else
                print("Path calculation failed in Guard mode (out of range)")
                pathfindingEnabled = false
                pathfindButton.Text = "Pathfind: Off"
                pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            end
        else -- Within followDistance, move randomly every 2 seconds
            -- Turn off pathfinding only when within range
            if pathfindingEnabled then
                pathfindingEnabled = false
                pathfindButton.Text = "Pathfind: Off"
                pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            end

            if currentTime - lastGuardMoveTime >= guardMoveCooldown then
                local randomAngle = math.random() * 2 * math.pi
                local randomRadius = math.random() * followDistance -- Move within the follow distance
                local randomOffset = Vector3.new(math.cos(randomAngle) * randomRadius, 0, math.sin(randomAngle) * randomRadius)
                local randomDestination = targetRootPart.Position + randomOffset

                localHumanoid:MoveTo(randomDestination)
                lastGuardMoveTime = currentTime
            end
        end
        return -- Exit early if in Guard mode
    end

    -- Normal follow/dodge logic (only if not in Guard mode)
    -- Turn off pathfinding if too close to the target
    if distance <= 3 then
        pathfindingEnabled = false
        pathfindButton.Text = "Pathfind: Off"
        pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end

    -- Check for movement if pathfinding is enabled
    if pathfindingEnabled then
        if lastPosition then
            local movedDistance = (localRootPart.Position - lastPosition).Magnitude
            if movedDistance < 0.5 then
                notMovingCounter = notMovingCounter + 1
                if notMovingCounter >= 3 then -- If not moved for 3 checks (1.5 seconds)
                    -- Not moving, try raycasting again
                    pathfindingEnabled = false
                    pathfindButton.Text = "Pathfind: Off"
                    pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    notMovingCounter = 0 -- Reset counter
                end
            else
                notMovingCounter = 0 -- Reset counter if moved
            end
        else
            notMovingCounter = 0 -- Reset counter if no last position
        end
        lastPosition = localRootPart.Position
    end

    if math.abs(distance - followDistance) > 1 then
        local direction = (targetRootPart.Position - localRootPart.Position).unit
        local destination = targetRootPart.Position - (direction * followDistance)

        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {localCharacter}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

        local rayResult = workspace:Raycast(localRootPart.Position, direction * followDistance, raycastParams)
        if rayResult and not pathfindingEnabled then
            -- Obstacle detected, check for shaking
            local lastPosition = localRootPart.Position
            task.wait(0.1) -- Wait for a short duration to check for movement
            local currentPosition = localRootPart.Position
            local movedDistance = (currentPosition - lastPosition).Magnitude

            if movedDistance < 0.5 then -- Threshold for detecting shaking
                isShaking = true
            else
                isShaking = false
            end

            if isShaking then
                pathfindingEnabled = true -- Enable pathfinding if shaking
                pathfindButton.Text = "Pathfind: On"
                pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
            end

            if not pathfindingEnabled then
                local dodgeOptions = {
                    Vector3.new(-direction.Z, 0, direction.X).unit,   -- Perpendicular left
                    Vector3.new(direction.Z, 0, -direction.X).unit,   -- Perpendicular right
                    direction * 0.5,                                  -- Halfway forward
                    -direction                                        -- Opposite (back)
                }

                for _, dodgeDirection in ipairs(dodgeOptions) do
                    local dodgePosition = localRootPart.Position + (dodgeDirection * dodgeDistance)
                    local dodgeRayResult = workspace:Raycast(localRootPart.Position, dodgeDirection * dodgeDistance, raycastParams)

                    if not dodgeRayResult then
                        destination = dodgePosition
                        break
                    end
                end
            end
        end

        if pathfindingEnabled then
            local path = calculatePath(localRootPart.Position, targetRootPart.Position)
            if path.Status == Enum.PathStatus.Success then
                local waypoints = path:GetWaypoints()
                for i, waypoint in ipairs(waypoints) do
                    if i > 1 then -- Skip the first waypoint which is the starting position
                        localHumanoid:MoveTo(waypoint.Position)
                        if waypoint.Action == Enum.PathWaypointAction.Jump then
                            localHumanoid.Jump = true
                        end
                        localHumanoid.MoveToFinished:Wait()
                        break -- Move to one waypoint at a time
                    end
                end
            else
                -- Handle path calculation failure
                print("Path calculation failed")
                pathfindingEnabled = false -- Disable pathfinding if it fails
                pathfindButton.Text = "Pathfind: Off"
                pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            end
        else
            localHumanoid:MoveTo(destination)
        end

    elseif distance < dodgeDistance then
        local retreatDirection = (localRootPart.Position - targetRootPart.Position).unit
        local retreatPosition = localRootPart.Position + (retreatDirection * dodgeDistance * 0.5)
        localHumanoid:MoveTo(retreatPosition)
    end
end

-- Loop for following/dodging
local followLoop
local function startFollowing()
    if followLoop then return end
    followLoop = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if lookAtEnabled then
            -- If Warning is enabled AND Guard is on, targetPlayer is ignored for Warning logic
            -- Otherwise, use the player from the input box
            if not (warningEnabled and guardEnabled) then
                targetPlayer = findPlayerByName(playerInput.Text)
            end
            moveToPlayer(targetPlayer)
        end
    end)
end

local function stopFollowing()
    if followLoop then
        followLoop:Disconnect()
        followLoop = nil
    end
end

-- Update status label
local function updateStatusLabel()
    local guardStatus = guardEnabled and "On" or "Off"
    local warningStatus = warningEnabled and "On" or "Off"
	statusLabel.Text = "Status: On (Follow: " .. tostring(followDistance) .. " studs, Dodge: " .. tostring(dodgeDistance) .. " studs, Guard: " .. guardStatus .. ", Warning: " .. warningStatus .. ")"
end

-- Function to create Frame 2
local function createFrame2()
    frame2 = Instance.new("Frame")
    frame2.Parent = screenGui
    frame2.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    frame2.Size = UDim2.new(0, 220, 0, 260) -- Same size as main frame
    frame2.Active = false -- Not draggable
    frame2.Draggable = false -- Not draggable

    local uicorner2 = Instance.new("UICorner")
    uicorner2.CornerRadius = UDim.new(0, 10)
    uicorner2.Parent = frame2

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Parent = frame2
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    titleLabel.Text = "Additional Options"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextScaled = true
    titleLabel.Font = Enum.Font.SourceSansBold

    -- --- NEW WARNING BUTTON ---
    warningButton = createButton(frame2, UDim2.new(0, 20, 0, 40), UDim2.new(0, 180, 0, 30), Color3.fromRGB(255, 165, 0), "⚠️ Warning ⚠️: Off", true)
    warningButton.MouseButton1Click:Connect(function()
        warningEnabled = not warningEnabled
        if warningEnabled then
            warningButton.Text = "⚠️ Warning ⚠️: On"
            warningButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red for warning
        else
            warningButton.Text = "⚠️ Warning ⚠️: Off"
            warningButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0) -- Orange when off
        end
        updateStatusLabel()
    end)
    -- --- END NEW WARNING BUTTON ---

    -- Position Frame 2 relative to Frame 1
    local function updateFrame2Position()
        if frame and frame2 then
            -- Calculate position to be to the left of frame1 with a small gap
            local newX = frame.Position.X.Scale - frame2.Size.X.Scale - 0.01 -- 0.01 for a small gap
            local newY = frame.Position.Y.Scale
            frame2.Position = UDim2.new(newX, frame.Position.X.Offset - frame2.Size.X.Offset - 10, newY, frame.Position.Y.Offset)
        end
    end

    -- Initial positioning
    updateFrame2Position()

    -- Connect Frame1's position changes to Frame2's position
    frame:GetPropertyChangedSignal("Position"):Connect(updateFrame2Position)

    print("Frame 2 created and linked.")
end

-- New event connection for player input
playerInput.Changed:Connect(function()
    targetPlayer = findPlayerByName(playerInput.Text)
end)

-- Button Event Listeners
plusButton.MouseButton1Click:Connect(function()
	followDistance = math.min(30, followDistance + 1)
	dodgeDistance = math.min(30, dodgeDistance + 1)
	updateStatusLabel()
end)

minusButton.MouseButton1Click:Connect(function()
	followDistance = math.max(1, followDistance - 1)
	dodgeDistance = math.max(1, dodgeDistance - 1)
	updateStatusLabel()
end)

onButton.MouseButton1Click:Connect(function()
    lookAtEnabled = true
    updateStatusLabel()
    statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    startFollowing()
end)

offButton.MouseButton1Click:Connect(function()
    lookAtEnabled = false
    pathfindingEnabled = false
    pathfindButton.Text = "Pathfind: Off"
    pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    statusLabel.Text = "Status: Off"
    statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    stopFollowing()

    -- If Guard was on, turn it off
    if guardEnabled then
        guardEnabled = false
        guardButton.Text = "Guard: Off"
        guardButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    end
    -- Warning button state is NOT changed here, only its functionality is affected by Guard being off.
    -- The warningEnabled variable itself remains as the user set it.
    updateStatusLabel() -- Update status to reflect Guard change
end)

guardButton.MouseButton1Click:Connect(function()
    if lookAtEnabled then -- Only allow Guard to be turned on if "On" is active
        guardEnabled = not guardEnabled
        if guardEnabled then
            guardButton.Text = "Guard: On"
            guardButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Green when on
            -- Reset lastGuardMoveTime to immediately trigger a move
            lastGuardMoveTime = 0
            -- Pathfinding state will be managed dynamically within moveToPlayer
        else
            guardButton.Text = "Guard: Off"
            guardButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255) -- Blue when off
            -- When guard is off, pathfinding state should revert to its previous setting or default off
            pathfindingEnabled = false
            pathfindButton.Text = "Pathfind: Off"
            pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            -- IMPORTANT: Warning button state is NOT changed here.
            -- Its functionality is simply disabled by the 'if warningEnabled and guardEnabled' check in moveToPlayer.
        end
        updateStatusLabel()
    else
        warn("Cannot enable Guard mode when 'On' is not active.")
    end
end)

pathfindButton.MouseButton1Click:Connect(function()
    if not guardEnabled then -- Pathfinding can only be toggled if Guard is off
        pathfindingEnabled = not pathfindingEnabled
        if pathfindingEnabled then
            pathfindButton.Text = "Pathfind: On"
            pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
        else
            pathfindButton.Text = "Pathfind: Off"
            pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        end
    else
        warn("Pathfinding cannot be toggled while Guard mode is active.")
    end
end)

additionButton.MouseButton1Click:Connect(function()
    additionEnabled = not additionEnabled
    if additionEnabled then
        additionButton.Text = "Addition: On"
        additionButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Green when on
        if not frame2 then
            createFrame2()
        else
            frame2.Visible = true
        end
    else
        additionButton.Text = "Addition: Off"
        additionButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150) -- Grey when off
        if frame2 then
            frame2.Visible = false
        end
    end
end)

destroyButton.MouseButton1Click:Connect(function()
    -- Stop following and pathfinding
    lookAtEnabled = false
    pathfindingEnabled = false
    guardEnabled = false -- Turn off guard
    warningEnabled = false -- Turn off warning (this is fine for full destroy)
    stopFollowing()

    -- Reset button states
    pathfindButton.Text = "Pathfind: Off"
    pathfindButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    guardButton.Text = "Guard: Off"
    guardButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    additionButton.Text = "Addition: Off"
    additionButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
    if warningButton then -- Only reset if it exists
        warningButton.Text = "⚠️ Warning ⚠️: Off"
        warningButton.BackgroundColor3 = Color3.fromRGB(255, 165, 0)
    end

    -- Reset status label
    statusLabel.Text = "Status: Off"
    statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)

    -- Clear target player
    targetPlayer = nil
    playerInput.Text = ""

    -- Destroy Frame 2 if it exists
    if frame2 then
        frame2:Destroy()
        frame2 = nil
        warningButton = nil -- Clear reference
    end

    -- Destroy the GUI
    screenGui:Destroy()
end)
